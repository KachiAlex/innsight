import { Router } from 'express';
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { AppError } from '../middleware/errorHandler';
import { authenticate, requireTenantAccess, AuthRequest } from '../middleware/auth';
import { createAuditLog } from '../utils/audit';
import { createAlert } from '../utils/alerts';
import { getPaginationParams, createPaginationResult } from '../utils/pagination';
import { prisma } from '../utils/prisma';
import { createRoomLog } from '../utils/roomLogs';
import { 
  sendEmail, 
  generateReservationConfirmationEmail, 
  generateCheckInReminderEmail,
  generateCheckOutThankYouEmail,
  getTenantEmailSettings,
  type ReservationEmailData,
} from '../utils/email';
import { v4 as uuidv4 } from 'uuid';
export const reservationRouter = Router({ mergeParams: true });

type PrismaClientLike = typeof prisma | Prisma.TransactionClient;

const resolveTenantUserId = async (
  client: PrismaClientLike,
  tenantId: string,
  providedUserId?: string | null
): Promise<string> => {
  if (providedUserId) {
    const existingUser = await client.user.findFirst({
      where: {
        id: providedUserId,
        tenantId,
      },
      select: { id: true },
    });
    if (existingUser) {
      return existingUser.id;
    }
  }

  const fallbackUser = await client.user.findFirst({
    where: { tenantId },
    select: { id: true },
    orderBy: { createdAt: 'asc' },
  });

  if (fallbackUser) {
    return fallbackUser.id;
  }

  const sanitizedTenantSegment = tenantId.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().slice(0, 12);
  const systemEmail = `system+${sanitizedTenantSegment || 'tenant'}@innsight.local`;

  const systemUser = await client.user.create({
    data: {
      tenantId,
      email: systemEmail,
      passwordHash: 'system-user-autogenerated',
      firstName: 'System',
      lastName: 'User',
      role: 'system',
      permissions: {},
      isActive: true,
    },
    select: { id: true },
  });

  return systemUser.id;
};

const getUserDisplayName = (user?: {
  firstName?: string | null;
  lastName?: string | null;
  email?: string | null;
}) => {
  if (!user) return null;
  const name = [user.firstName, user.lastName].filter(Boolean).join(' ').trim();
  return name || user.email || null;
};

const decimalToNumber = (value?: Prisma.Decimal | null) =>
  value !== null && value !== undefined ? Number(value) : null;

const resolveRoomEffectiveRate = (room: {
  customRate?: Prisma.Decimal | number | null;
  ratePlan?: { baseRate?: Prisma.Decimal | number | null } | null;
}) => {
  const customRate = decimalToNumber(room.customRate as Prisma.Decimal | null);
  if (customRate !== null) {
    return customRate;
  }
  const baseRate = decimalToNumber(room.ratePlan?.baseRate as Prisma.Decimal | null);
  return baseRate;
};

const serializeReservation = (reservation: any) => {
  if (!reservation) return reservation;
  return {
    ...reservation,
    rate: decimalToNumber(reservation.rate),
    depositAmount: decimalToNumber(reservation.depositAmount),
  };
};

type RoomReservationSummary = {
  reservationId: string;
  reservationNumber: string | null;
  status: string | null;
  checkInDate: Date | null;
  checkOutDate: Date | null;
  guestName: string | null;
};

const serializeFolio = (folio: any) => {
  if (!folio) return folio;
  return {
    ...folio,
    totalCharges: decimalToNumber(folio.totalCharges) ?? 0,
    totalPayments: decimalToNumber(folio.totalPayments) ?? 0,
    balance: decimalToNumber(folio.balance) ?? 0,
    charges: (folio.charges ?? []).map((charge: any) => ({
      ...charge,
      amount: decimalToNumber(charge.amount) ?? 0,
      total: decimalToNumber(charge.total) ?? 0,
      taxRate: decimalToNumber(charge.taxRate),
      taxAmount: decimalToNumber(charge.taxAmount),
    })),
    payments: (folio.payments ?? []).map((payment: any) => ({
      ...payment,
      amount: decimalToNumber(payment.amount) ?? 0,
    })),
  };
};

const mapHallRecord = (hall: {
  id: string;
  tenantId: string;
  name: string;
  description: string | null;
  capacity: number;
  location: string | null;
  amenities: Prisma.JsonValue | null;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}) => {
  const amenitiesObject =
    (hall.amenities as Record<string, unknown> | null | undefined) ?? {};
  const assets = Array.isArray((amenitiesObject as any).assets)
    ? ((amenitiesObject as any).assets as unknown[]).filter(
        (item) => typeof item === 'string'
      )
    : [];

  return {
    id: hall.id,
    tenantId: hall.tenantId,
    name: hall.name,
    description: hall.description,
    capacity: hall.capacity,
    location: hall.location,
    assets,
    isActive: hall.isActive,
    createdAt: hall.createdAt,
    updatedAt: hall.updatedAt,
  };
};

const availabilityQuerySchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  roomType: z.string().optional(),
  categoryId: z.string().optional(),
  ratePlanId: z.string().optional(),
  minOccupancy: z.coerce.number().int().min(1).optional(),
  floor: z.coerce.number().int().optional(),
  minRate: z.coerce.number().nonnegative().optional(),
  maxRate: z.coerce.number().nonnegative().optional(),
  includeOutOfOrder: z.coerce.boolean().optional(),
});

const createReservationBatchSchema = z
  .object({
    guestName: z.string().min(1),
    guestEmail: z.preprocess(
      (val) => (val === '' || val === null || val === undefined ? undefined : val),
      z.string().email().optional()
    ),
    guestPhone: z.preprocess(
      (val) => (val === '' || val === null || val === undefined ? undefined : val),
      z.string().optional()
    ),
    guestIdNumber: z.preprocess(
      (val) => (val === '' || val === null || val === undefined ? undefined : val),
      z.string().optional()
    ),
    checkInDate: z.string().datetime(),
    checkOutDate: z.string().datetime(),
    adults: z.number().int().min(1).default(1),
    children: z.number().int().min(0).default(0),
    depositAmount: z.number().nonnegative().optional(),
    source: z.enum(['manual', 'web', 'ota', 'channel_manager']).default('manual'),
    specialRequests: z.preprocess(
      (val) => (val === '' || val === null || val === undefined ? undefined : val),
      z.string().optional()
    ),
    rooms: z
      .array(
        z.object({
          roomId: z.string().min(1),
          rate: z.number().positive(),
        })
      )
      .default([]),
    hallReservations: z
      .array(
        z.object({
          hallId: z.string().uuid(),
          eventName: z.string().optional(),
          purpose: z.string().optional(),
          setupType: z.string().optional(),
          attendeeCount: z.union([z.number().int().min(0), z.string()]).optional(),
          startDateTime: z.string().datetime(),
          endDateTime: z.string().datetime(),
          cateringNotes: z.string().optional(),
          avRequirements: z.string().optional(),
          rate: z.union([z.number().nonnegative(), z.string()]).optional(),
          status: z.string().optional(),
        })
      )
      .optional(),
  })
  .refine(
    (data) =>
      (Array.isArray(data.rooms) && data.rooms.length > 0) ||
      (Array.isArray(data.hallReservations) && data.hallReservations.length > 0),
    {
      message: 'At least one room or hall reservation is required',
      path: ['rooms'],
    }
  );

const validateHallReservationsForBatch = async (
  tenantId: string,
  hallReservations: any[],
  client: any
) => {
  if (!Array.isArray(hallReservations) || hallReservations.length === 0) return;

  const hallIds = [...new Set(hallReservations.map((hr) => hr.hallId))];
  const halls = await client.meetingHall.findMany({
    where: {
      tenantId,
      id: { in: hallIds },
      isActive: true,
    },
    select: { id: true },
  });

  const validHallIds = new Set(halls.map((hall: any) => hall.id));
  hallReservations.forEach((reservation) => {
    if (!reservation.hallId || !validHallIds.has(reservation.hallId)) {
      throw new AppError(`Meeting hall ${reservation.hallId} is not available for this tenant`, 400);
    }

    if (!reservation.startDateTime || !reservation.endDateTime) {
      throw new AppError('Hall reservations require start and end date/time', 400);
    }

    const start = new Date(reservation.startDateTime);
    const end = new Date(reservation.endDateTime);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime()) || start >= end) {
      throw new AppError('Invalid hall reservation date range', 400);
    }
  });

  for (const reservation of hallReservations) {
    const start = new Date(reservation.startDateTime);
    const end = new Date(reservation.endDateTime);
    const overlap = await client.groupBookingHallReservation.findFirst({
      where: {
        tenantId,
        hallId: reservation.hallId,
        startDateTime: { lt: end },
        endDateTime: { gt: start },
        status: { in: ['tentative', 'confirmed'] },
      },
      select: { id: true },
    });

    if (overlap) {
      throw new AppError('Selected hall already has a booking for the requested schedule', 409);
    }
  }
};

const getHallAvailability = async (tenantId: string, start: Date, end: Date) => {
  if (!prisma) {
    throw new AppError('Database connection not initialized', 500);
  }

  const halls = await prisma.meetingHall.findMany({
    where: {
      tenantId,
      isActive: true,
    },
    orderBy: {
      name: 'asc',
    },
  });

  if (halls.length === 0) {
    return {
      totalHalls: 0,
      availableCount: 0,
      availableHalls: [],
      unavailableHalls: [],
    };
  }

  const overlappingHallReservations = await prisma.groupBookingHallReservation.findMany({
    where: {
      tenantId,
      status: {
        in: ['tentative', 'confirmed'],
      },
      startDateTime: { lt: end },
      endDateTime: { gt: start },
    },
    select: {
      id: true,
      hallId: true,
      eventName: true,
      status: true,
      startDateTime: true,
      endDateTime: true,
      groupBookingId: true,
    },
  });

  const reservationsByHall = new Map<string, typeof overlappingHallReservations>();
  overlappingHallReservations.forEach((reservation) => {
    const existing = reservationsByHall.get(reservation.hallId) ?? [];
    existing.push(reservation);
    reservationsByHall.set(reservation.hallId, existing);
  });

  const availableHalls: any[] = [];
  const unavailableHalls: any[] = [];

  halls.forEach((hall) => {
    const normalized = mapHallRecord(hall);
    const overlaps = reservationsByHall.get(hall.id) ?? [];

    if (overlaps.length === 0) {
      availableHalls.push(normalized);
      return;
    }

    unavailableHalls.push({
      ...normalized,
      reservations: overlaps.map((reservation) => ({
        id: reservation.id,
        groupBookingId: reservation.groupBookingId,
        eventName: reservation.eventName,
        status: reservation.status,
        startDateTime: reservation.startDateTime.toISOString(),
        endDateTime: reservation.endDateTime.toISOString(),
      })),
    });
  });

  return {
    totalHalls: halls.length,
    availableCount: availableHalls.length,
    availableHalls,
    unavailableHalls,
  };
};

const createReservationSchema = z.object({
  roomId: z.string().min(1),
  guestName: z.string().min(1),
  guestEmail: z.preprocess(
    (val) => (val === '' || val === null || val === undefined ? undefined : val),
    z.string().email().optional()
  ),
  guestPhone: z.preprocess(
    (val) => (val === '' || val === null || val === undefined ? undefined : val),
    z.string().optional()
  ),
  guestIdNumber: z.preprocess(
    (val) => (val === '' || val === null || val === undefined ? undefined : val),
    z.string().optional()
  ),
  checkInDate: z.string().datetime(),
  checkOutDate: z.string().datetime(),
  adults: z.number().int().min(1).default(1),
  children: z.number().int().min(0).default(0),
  rate: z.number().positive(),
  depositAmount: z.number().nonnegative().optional(),
  source: z.enum(['manual', 'web', 'ota', 'channel_manager']).default('manual'),
  specialRequests: z.preprocess(
    (val) => (val === '' || val === null || val === undefined ? undefined : val),
    z.string().optional()
  ),
});

// POST /api/tenants/:tenantId/reservations
// GET /api/tenants/:tenantId/reservations/availability
reservationRouter.get(
  '/availability',
  authenticate,
  requireTenantAccess,
  async (req: AuthRequest, res) => {
    try {
      const tenantId = req.params.tenantId;
      if (!prisma) {
        throw new AppError('Database connection not initialized', 500);
      }
      const parsed = availabilityQuerySchema.safeParse(req.query);

      if (!parsed.success) {
        throw new AppError('Invalid availability query parameters', 400);
      }

      const {
        startDate,
        endDate,
        roomType,
        categoryId,
        ratePlanId,
        minOccupancy,
        floor,
        minRate,
        maxRate,
        includeOutOfOrder,
      } = parsed.data;

      const start = new Date(startDate);
      const end = new Date(endDate);

      if (end <= start) {
        throw new AppError('End date must be after start date', 400);
      }
      if (minRate !== undefined && maxRate !== undefined && Number(minRate) > Number(maxRate)) {
        throw new AppError('Minimum rate cannot be greater than maximum rate', 400);
      }

          const blockedStatuses = includeOutOfOrder ? [] : ['out_of_order', 'maintenance'];

      const rooms = await prisma.room.findMany({
        where: {
          tenantId,
          ...(roomType ? { roomType } : {}),
          ...(typeof floor === 'number' ? { floor } : {}),
          ...(includeOutOfOrder
            ? {}
            : {
                status: {
                  notIn: blockedStatuses,
                },
              }),
          ...(minOccupancy
            ? {
                maxOccupancy: {
                  gte: minOccupancy,
                },
              }
            : {}),
          ...(categoryId
            ? categoryId === 'none'
              ? {
                  categoryId: null,
                }
              : { categoryId }
            : {}),
          ...(ratePlanId ? { ratePlanId } : {}),
        },
        include: {
          ratePlan: true,
          category: true,
        },
      });

      const categoryRatePlans = await prisma.ratePlan.findMany({
        where: {
          tenantId,
          isActive: true,
          categoryId: {
            not: null,
          },
        },
        select: {
          id: true,
          name: true,
          baseRate: true,
          categoryId: true,
        },
      });

      const categoryRatePlanMap = new Map<string, typeof categoryRatePlans[0]>();
      for (const plan of categoryRatePlans) {
        if (!plan.categoryId) continue;
        const existing = categoryRatePlanMap.get(plan.categoryId);
        if (!existing) {
          categoryRatePlanMap.set(plan.categoryId, plan);
          continue;
        }
        const existingRate = decimalToNumber(existing.baseRate as Prisma.Decimal | null);
        const newRate = decimalToNumber(plan.baseRate as Prisma.Decimal | null);
        if (newRate !== null && (existingRate === null || newRate < existingRate)) {
          categoryRatePlanMap.set(plan.categoryId, plan);
        }
      }

      if (rooms.length === 0) {
        res.json({
          success: true,
          data: {
            startDate: start.toISOString(),
            endDate: end.toISOString(),
            totalRooms: 0,
            availableCount: 0,
            availableRooms: [],
            unavailableRooms: [],
          },
        });
        return;
      }

      const allowedRoomIds = rooms.map((room) => room.id);

      const overlappingReservations = await prisma.reservation.findMany({
        where: {
          tenantId,
          status: {
            in: ['confirmed', 'checked_in'],
          },
          roomId: {
            in: allowedRoomIds,
          },
        },
        select: {
          id: true,
          reservationNumber: true,
          status: true,
          checkInDate: true,
          checkOutDate: true,
          guestName: true,
          roomId: true,
        },
      });

      const unavailableRoomReservations: Map<string, RoomReservationSummary[]> = new Map();

      for (const reservation of overlappingReservations) {
        const overlaps =
          reservation.checkInDate < end && reservation.checkOutDate > start;

        if (!overlaps || !reservation.roomId) {
          continue;
        }

        const summaries = unavailableRoomReservations.get(reservation.roomId) ?? [];
        summaries.push({
          reservationId: reservation.id,
          reservationNumber: reservation.reservationNumber,
          status: reservation.status,
          checkInDate: reservation.checkInDate,
          checkOutDate: reservation.checkOutDate,
          guestName: reservation.guestName,
        });
        unavailableRoomReservations.set(reservation.roomId, summaries);
      }

      const availableRoomsRaw = rooms.filter((room: any) => {
        if (!room?.id) return false;
        if (unavailableRoomReservations.has(room.id)) {
          return false;
        }
        return true;
      });

      const availableRoomsWithRates = availableRoomsRaw.map((room) => {
        const fallbackRatePlan =
          !room.ratePlan && room.categoryId ? categoryRatePlanMap.get(room.categoryId) : null;
        const selectedRatePlan = room.ratePlan ?? fallbackRatePlan ?? null;
        const ratePlanBaseRate = selectedRatePlan
          ? decimalToNumber(selectedRatePlan.baseRate as Prisma.Decimal | null)
          : null;
        const effectiveRate = resolveRoomEffectiveRate({
          customRate: room.customRate,
          ratePlan: selectedRatePlan
            ? {
                baseRate: ratePlanBaseRate,
              }
            : null,
        });

        return {
          id: room.id,
          roomNumber: room.roomNumber || '',
          roomType: room.roomType || '',
          floor: typeof room.floor === 'number' ? room.floor : null,
          status: room.status || 'available',
          maxOccupancy: room.maxOccupancy || 0,
          amenities: room.amenities || null,
          categoryId: room.categoryId || null,
          ratePlanId: room.ratePlanId ?? fallbackRatePlan?.id ?? null,
          ratePlan: selectedRatePlan
            ? {
                id: selectedRatePlan.id,
                name: selectedRatePlan.name,
                baseRate: ratePlanBaseRate,
              }
            : null,
          category: room.category
            ? {
                id: room.category.id,
                name: room.category.name,
              }
            : null,
          customRate: decimalToNumber(room.customRate as Prisma.Decimal | null),
          effectiveRate,
        };
      });

      const availableRooms = availableRoomsWithRates.filter((room) => {
        const effectiveRate = room.effectiveRate ?? null;

        if (minRate !== undefined) {
          if (effectiveRate === null || effectiveRate < Number(minRate)) {
            return false;
          }
        }
        if (maxRate !== undefined) {
          if (effectiveRate === null || effectiveRate > Number(maxRate)) {
            return false;
          }
        }
        return true;
      });

      const unavailableRooms = Array.from(
        unavailableRoomReservations.entries()
      ).map(([roomId, reservations]: [string, RoomReservationSummary[]]) => ({
        roomId,
        reservations: reservations.map((reservation) => ({
          ...reservation,
          checkInDate: reservation.checkInDate?.toISOString?.() || null,
          checkOutDate: reservation.checkOutDate?.toISOString?.() || null,
        })),
      }));

      const recommendedRooms = availableRoomsWithRates
        .filter((room) => room.status !== 'available')
        .map((room) => {
          const effectiveRate = room.effectiveRate ?? null;

          return {
            id: room.id,
            roomNumber: room.roomNumber,
            roomType: room.roomType,
            status: room.status,
            rate: effectiveRate,
            categoryId: room.categoryId,
            ratePlan: room.ratePlan,
          };
        })
        .slice(0, 3);

      const hallAvailability = await getHallAvailability(tenantId, start, end);

      res.json({
        success: true,
        data: {
          startDate: start.toISOString(),
          endDate: end.toISOString(),
          totalRooms: rooms.length,
          availableCount: availableRooms.length,
          availableRooms,
          unavailableRooms,
          recommendedRooms,
          hallAvailability,
        },
      });
    } catch (error: any) {
      if (error instanceof AppError) {
        throw error;
      }
      console.error('Error checking availability:', error);
      throw new AppError(
        `Failed to fetch availability: ${error.message || 'Database connection error'}`,
        500
      );
    }
  }
);

reservationRouter.post(
  '/',
  authenticate,
  requireTenantAccess,
  async (req: AuthRequest, res) => {
    try {
      const tenantId = req.params.tenantId;
      if (!prisma) {
        throw new AppError('Database connection not initialized', 500);
      }
      const data = createReservationSchema.parse(req.body);

      // Validate dates
      const checkIn = new Date(data.checkInDate);
      const checkOut = new Date(data.checkOutDate);
      if (checkOut <= checkIn) {
        throw new AppError('Check-out date must be after check-in date', 400);
      }

      // Validate room
      const room = await prisma.room.findFirst({
        where: {
          id: data.roomId,
          tenantId,
        },
      });

      if (!room) {
        throw new AppError('Room not found', 404);
      }

      // Check for overlapping reservations
      const overlapping = await prisma.reservation.findFirst({
        where: {
          tenantId,
          roomId: data.roomId,
          status: {
            in: ['confirmed', 'checked_in'],
          },
          AND: [
            {
              checkInDate: {
                lt: checkOut,
              },
            },
            {
              checkOutDate: {
                gt: checkIn,
              },
            },
          ],
        },
        select: { id: true },
      });

      if (overlapping) {
        throw new AppError('Room is not available for the selected dates', 400);
      }

      const reservationNumber = `RES-${Date.now()}-${uuidv4().substring(0, 8).toUpperCase()}`;

      const reservation = await prisma.reservation.create({
        data: {
          tenantId,
          roomId: data.roomId,
          reservationNumber,
          guestName: data.guestName,
          guestEmail: data.guestEmail || null,
          guestPhone: data.guestPhone || null,
          guestIdNumber: data.guestIdNumber || null,
          checkInDate: checkIn,
          checkOutDate: checkOut,
          adults: data.adults,
          children: data.children,
          rate: new Prisma.Decimal(data.rate),
          depositAmount:
            data.depositAmount !== undefined
              ? new Prisma.Decimal(data.depositAmount)
              : null,
          depositStatus: data.depositAmount ? 'pending' : null,
          depositRequired: data.depositAmount ? true : false,
          source: data.source,
          specialRequests: data.specialRequests || null,
          createdBy: req.user!.id,
          status: 'confirmed',
        },
        include: {
          room: true,
          creator: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
      });

      const serializedReservation = {
        ...reservation,
        rate: Number(reservation.rate),
        depositAmount: reservation.depositAmount
          ? Number(reservation.depositAmount)
          : null,
      };

      await createAuditLog({
        tenantId,
        userId: req.user!.id,
        action: 'create_reservation',
        entityType: 'reservation',
        entityId: reservation.id,
        afterState: serializedReservation,
        metadata: {
          reservationNumber,
        },
      });

      await createRoomLog({
        tenantId,
        roomId: data.roomId,
        type: 'reservation_created',
        summary: `Reservation ${reservationNumber} created for ${data.guestName}`,
        metadata: {
          reservationId: reservation.id,
          reservationNumber,
          checkInDate: checkIn.toISOString(),
          checkOutDate: checkOut.toISOString(),
          guestName: data.guestName,
        },
        user: {
          id: req.user?.id || null,
          name: getUserDisplayName(req.user),
        },
      });

      // Send confirmation email asynchronously (don't block response)
      if (data.guestEmail) {
        (async () => {
          try {
            const tenantSettings = await getTenantEmailSettings(tenantId);
            if (tenantSettings) {
              const emailData: ReservationEmailData = {
                reservationNumber,
                guestName: data.guestName,
                guestEmail: data.guestEmail!,
                checkInDate: checkIn,
                checkOutDate: checkOut,
                roomNumber: room.roomNumber || 'N/A',
                roomType: room.roomType || undefined,
                rate: data.rate,
                adults: data.adults,
                children: data.children,
                specialRequests: data.specialRequests || undefined,
                propertyName: tenantSettings.propertyName,
                propertyAddress: tenantSettings.propertyAddress || undefined,
                propertyPhone: tenantSettings.propertyPhone || undefined,
                propertyEmail: tenantSettings.propertyEmail || undefined,
              };

              const emailHtml = generateReservationConfirmationEmail(emailData);
              await sendEmail({
                to: data.guestEmail!,
                subject: `Reservation Confirmation - ${reservationNumber}`,
                html: emailHtml,
              });
            }
          } catch (emailError) {
            console.error('Failed to send reservation confirmation email:', emailError);
            // Don't throw - email failure shouldn't fail the reservation creation
          }
        })();
      }

      res.status(201).json({
        success: true,
        data: serializedReservation,
      });
    } catch (error: any) {
      if (error instanceof AppError) {
        throw error;
      }
      if (error instanceof z.ZodError) {
        const message = error.errors?.map((issue) => `${issue.path.join('.')}: ${issue.message}`).join(', ') || 'Invalid reservation data';
        throw new AppError(message, 400);
      }
      console.error('Error creating reservation:', error);
      throw new AppError(
        `Failed to create reservation: ${error.message || 'Database connection error'}`,
        500
      );
    }
  }
);

reservationRouter.post(
  '/batch',
  authenticate,
  requireTenantAccess,
  async (req: AuthRequest, res) => {
    try {
      const tenantId = req.params.tenantId;
      if (!prisma) {
        throw new AppError('Database connection not initialized', 500);
      }

      const data = createReservationBatchSchema.parse(req.body);

      const checkIn = new Date(data.checkInDate);
      const checkOut = new Date(data.checkOutDate);
      if (checkOut <= checkIn) {
        throw new AppError('Check-out date must be after check-in date', 400);
      }

      const roomIds = data.rooms.map((room) => room.roomId);
      const uniqueRoomIds = [...new Set(roomIds)];
      if (uniqueRoomIds.length !== roomIds.length) {
        throw new AppError('Duplicate rooms are not allowed in a batch reservation', 400);
      }

      const halls = Array.isArray(data.hallReservations) ? data.hallReservations : [];

      const result = await prisma.$transaction(async (tx) => {
        const actorUserId = await resolveTenantUserId(tx, tenantId, req.user?.id);

        let rooms: Array<{ id: string; roomNumber: string | null; roomType: string | null }> = [];

        if (uniqueRoomIds.length > 0) {
          rooms = await tx.room.findMany({
            where: {
              tenantId,
              id: { in: uniqueRoomIds },
            },
            select: {
              id: true,
              roomNumber: true,
              roomType: true,
            },
          });

          if (rooms.length !== uniqueRoomIds.length) {
            throw new AppError('One or more rooms were not found for this tenant', 404);
          }

          const overlaps = await tx.reservation.findMany({
            where: {
              tenantId,
              roomId: { in: uniqueRoomIds },
              status: { in: ['confirmed', 'checked_in'] },
              checkInDate: { lt: checkOut },
              checkOutDate: { gt: checkIn },
            },
            select: {
              id: true,
              roomId: true,
            },
          });

          if (overlaps.length > 0) {
            const blockedRoomIds = [...new Set(overlaps.map((r) => r.roomId))];
            const blockedNumbers = rooms
              .filter((room) => blockedRoomIds.includes(room.id))
              .map((room) => room.roomNumber || room.id);
            throw new AppError(
              `Some rooms are not available for the selected dates: ${blockedNumbers.join(', ')}`,
              400
            );
          }
        }

        await validateHallReservationsForBatch(tenantId, halls, tx);

        const nights = Math.max(
          1,
          Math.ceil((checkOut.getTime() - checkIn.getTime()) / (1000 * 60 * 60 * 24))
        );

        const roomSubtotal = data.rooms.reduce((sum, room) => sum + Number(room.rate) * nights, 0);
        const hallSubtotal = halls.reduce((sum, hall) => sum + (Number((hall as any).rate) || 0), 0);
        const totalRevenue = roomSubtotal + hallSubtotal;

        const shouldCreateGroupBooking = data.rooms.length > 1 || halls.length > 0;
        let groupBooking: { id: string } | null = null;

        if (shouldCreateGroupBooking) {
          const groupBookingNumber = `GB-${new Date().toISOString()
            .slice(0, 10)
            .replace(/-/g, '')}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;

          groupBooking = await tx.groupBooking.create({
            data: {
              tenantId,
              groupBookingNumber,
              groupName: `Reservation - ${data.guestName}`,
              groupType: 'other',
              contactPerson: data.guestName,
              contactEmail: data.guestEmail || 'unknown@example.com',
              contactPhone: data.guestPhone || 'N/A',
              expectedGuests: Number(data.adults) + Number(data.children),
              confirmedGuests: 0,
              checkInDate: checkIn,
              checkOutDate: checkOut,
              totalRooms: data.rooms.length,
              totalRevenue: new Prisma.Decimal(totalRevenue),
              depositAmount:
                data.depositAmount !== undefined ? new Prisma.Decimal(data.depositAmount) : null,
              depositPaid: false,
              status: 'confirmed',
              bookingProgress: 'confirmed',
              specialRequests: data.specialRequests || null,
              dietaryRequirements: null,
              setupRequirements: null,
              assignedTo: null,
              createdBy: actorUserId,
              hallReservations: halls.length
                ? {
                    create: halls.map((reservation) => ({
                      tenantId,
                      hallId: reservation.hallId,
                      eventName: reservation.eventName || null,
                      purpose: reservation.purpose || null,
                      setupType: reservation.setupType || null,
                      attendeeCount:
                        reservation.attendeeCount !== undefined && reservation.attendeeCount !== null
                          ? Number(reservation.attendeeCount) || null
                          : null,
                      startDateTime: new Date(reservation.startDateTime),
                      endDateTime: new Date(reservation.endDateTime),
                      cateringNotes: reservation.cateringNotes || null,
                      avRequirements: reservation.avRequirements || null,
                      status: reservation.status || 'tentative',
                    })),
                  }
                : undefined,
            },
          });
        }

        const createdReservations = data.rooms.length
          ? await Promise.all(
              data.rooms.map(async (room) => {
                const reservationNumber = `RES-${Date.now()}-${uuidv4()
                  .substring(0, 8)
                  .toUpperCase()}`;
                return tx.reservation.create({
                  data: {
                    tenantId,
                    roomId: room.roomId,
                    groupBookingId: groupBooking?.id ?? null,
                    reservationNumber,
                    guestName: data.guestName,
                    guestEmail: data.guestEmail || null,
                    guestPhone: data.guestPhone || null,
                    guestIdNumber: data.guestIdNumber || null,
                    checkInDate: checkIn,
                    checkOutDate: checkOut,
                    adults: data.adults,
                    children: data.children,
                    rate: new Prisma.Decimal(room.rate),
                    depositAmount:
                      data.depositAmount !== undefined ? new Prisma.Decimal(data.depositAmount) : null,
                    depositStatus: data.depositAmount ? 'pending' : null,
                    depositRequired: data.depositAmount ? true : false,
                    source: data.source,
                    specialRequests: data.specialRequests || null,
                    createdBy: actorUserId,
                    status: 'confirmed',
                  },
                  include: {
                    room: true,
                  },
                });
              })
            )
          : [];

        return {
          groupBookingId: groupBooking?.id ?? null,
          reservationIds: createdReservations.map((r) => r.id),
          reservations: createdReservations,
        };
      });

      await Promise.all(
        result.reservations.map(async (reservation: any) => {
          const serializedReservation = {
            ...reservation,
            rate: decimalToNumber(reservation.rate),
            depositAmount: decimalToNumber(reservation.depositAmount),
          };

          const logGroupBookingId = result.groupBookingId ?? undefined;

          await createAuditLog({
            tenantId,
            userId: req.user!.id,
            action: 'create_reservation',
            entityType: 'reservation',
            entityId: reservation.id,
            afterState: serializedReservation,
            metadata: {
              reservationNumber: reservation.reservationNumber,
              groupBookingId: logGroupBookingId,
              batch: true,
            },
          });

          await createRoomLog({
            tenantId,
            roomId: reservation.roomId,
            type: 'reservation_created',
            summary: `Reservation ${reservation.reservationNumber} created for ${data.guestName}`,
            metadata: {
              reservationId: reservation.id,
              reservationNumber: reservation.reservationNumber,
              checkInDate: checkIn.toISOString(),
              checkOutDate: checkOut.toISOString(),
              guestName: data.guestName,
              groupBookingId: logGroupBookingId,
            },
            user: {
              id: req.user?.id || null,
              name: getUserDisplayName(req.user),
            },
          });
        })
      );

      res.status(201).json({
        success: true,
        data: {
          groupBookingId: result.groupBookingId,
          reservationIds: result.reservationIds,
          reservations: result.reservations.map((reservation: any) => serializeReservation(reservation)),
        },
      });
    } catch (error: any) {
      if (error instanceof AppError) {
        throw error;
      }
      if (error instanceof z.ZodError) {
        const message =
          error.errors?.map((issue) => `${issue.path.join('.')}: ${issue.message}`).join(', ') ||
          'Invalid reservation data';
        throw new AppError(message, 400);
      }
      console.error('Error creating batch reservations:', error);
      throw new AppError(
        `Failed to create reservations: ${error.message || 'Database connection error'}`,
        500
      );
    }
  }
);

// GET /api/tenants/:tenantId/reservations/:id
reservationRouter.get(
  '/:id',
  authenticate,
  requireTenantAccess,
  async (req: AuthRequest, res) => {
    try {
      const tenantId = req.params.tenantId;
      const reservationId = req.params.id;
      if (!prisma) {
        throw new AppError('Database connection not initialized', 500);
      }

      const reservation = await prisma.reservation.findFirst({
        where: {
          id: reservationId,
          tenantId,
        },
        include: {
          room: true,
          creator: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          checkInStaff: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          checkOutStaff: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          folios: {
            include: {
              charges: true,
              payments: true,
            },
          },
        },
      });

      if (!reservation) {
        throw new AppError('Reservation not found', 404);
      }

      const serializedReservation = {
        ...reservation,
        rate: decimalToNumber(reservation.rate),
        depositAmount: decimalToNumber(reservation.depositAmount),
        folios: reservation.folios.map((folio) => ({
          ...folio,
          totalCharges: decimalToNumber(folio.totalCharges) ?? 0,
          totalPayments: decimalToNumber(folio.totalPayments) ?? 0,
          balance: decimalToNumber(folio.balance) ?? 0,
          charges: folio.charges.map((charge) => ({
            ...charge,
            amount: decimalToNumber(charge.amount) ?? 0,
            total: decimalToNumber(charge.total) ?? 0,
            taxRate: decimalToNumber(charge.taxRate),
            taxAmount: decimalToNumber(charge.taxAmount),
          })),
          payments: folio.payments.map((payment) => ({
            ...payment,
            amount: decimalToNumber(payment.amount) ?? 0,
          })),
        })),
      };

      res.json({
        success: true,
        data: serializedReservation,
      });
    } catch (error: any) {
      if (error instanceof AppError) {
        throw error;
      }
      console.error('Error fetching reservation:', error);
      throw new AppError(
        `Failed to fetch reservation: ${error.message || 'Database connection error'}`,
        500
      );
    }
  }
);

// GET /api/tenants/:tenantId/reservations
reservationRouter.get(
  '/',
  authenticate,
  requireTenantAccess,
  async (req: AuthRequest, res) => {
    try {
      const tenantId = req.params.tenantId;
      if (!prisma) {
        throw new AppError('Database connection not initialized', 500);
      }

      const { status, roomId, startDate, endDate } = req.query;

      const { page, limit } = getPaginationParams(req);

      const where: Prisma.ReservationWhereInput = {
        tenantId,
        ...(status ? { status: status as string } : {}),
        ...(roomId ? { roomId: roomId as string } : {}),
      };

      const dateFilters: Prisma.ReservationWhereInput[] = [];
      if (startDate) {
        const start = new Date(startDate as string);
        if (Number.isNaN(start.getTime())) {
          throw new AppError('Invalid start date', 400);
        }
        dateFilters.push({
          checkInDate: {
            gte: start,
          },
        });
      }
      if (endDate) {
        const end = new Date(endDate as string);
        if (Number.isNaN(end.getTime())) {
          throw new AppError('Invalid end date', 400);
        }
        dateFilters.push({
          checkOutDate: {
            lte: end,
          },
        });
      }

      if (dateFilters.length > 0) {
        where.AND = where.AND ? [...(Array.isArray(where.AND) ? where.AND : [where.AND]), ...dateFilters] : dateFilters;
      }

      const skip = (page - 1) * limit;

      const [reservations, total] = await Promise.all([
        prisma.reservation.findMany({
          where,
          include: {
            room: {
              select: {
                id: true,
                roomNumber: true,
                roomType: true,
              },
            },
          },
          orderBy: {
            checkInDate: 'desc',
          },
          take: limit,
          skip,
        }),
        prisma.reservation.count({ where }),
      ]);

      const serializedReservations = reservations.map((reservation) => ({
        ...reservation,
        rate: decimalToNumber(reservation.rate),
        depositAmount: decimalToNumber(reservation.depositAmount),
      }));

      const result = createPaginationResult(serializedReservations, total, page, limit);

      res.json({
        success: true,
        ...result,
      });
    } catch (error: any) {
      console.error('Error fetching reservations:', error);
      throw new AppError(
        `Failed to fetch reservations: ${error.message || 'Database connection error'}`,
        500
      );
    }
  }
);

// POST /api/tenants/:tenantId/rooms/:roomId/checkin
reservationRouter.post(
  '/:id/checkin',
  authenticate,
  requireTenantAccess,
  async (req: AuthRequest, res) => {
    try {
      const tenantId = req.params.tenantId;
      const reservationId = req.params.id;
      const { photo } = req.body;
      if (!prisma) {
        throw new AppError('Database connection not initialized', 500);
      }

      const reservation = await prisma.reservation.findFirst({
        where: {
          id: reservationId,
          tenantId,
        },
        include: {
          room: true,
          folios: {
            include: {
              charges: true,
              payments: true,
            },
          },
        },
      });

      if (!reservation) {
        throw new AppError('Reservation not found', 404);
      }

      if (reservation.status !== 'confirmed') {
        throw new AppError('Reservation is not in confirmed status', 400);
      }

      if (!reservation.room) {
        throw new AppError('Reservation is missing room information', 400);
      }

      const beforeState = {
        ...serializeReservation(reservation),
        room: reservation.room,
        folios: reservation.folios.map(serializeFolio),
      };

      const checkInTime = new Date();
      const rateNumber = decimalToNumber(reservation.rate) ?? 0;

      await prisma.$transaction(async (tx) => {
        await tx.reservation.update({
          where: { id: reservation.id },
          data: {
            status: 'checked_in',
            checkedInAt: checkInTime,
            checkedInBy: req.user!.id,
          },
        });

        await tx.room.update({
          where: { id: reservation.roomId },
          data: {
            status: 'occupied',
          },
        });

        const existingFolio = await tx.folio.findFirst({
          where: {
            reservationId,
          },
        });

        if (!existingFolio) {
          const folio = await tx.folio.create({
            data: {
              tenantId,
              reservationId,
              roomId: reservation.roomId,
              guestName: reservation.guestName,
              createdBy: req.user!.id,
              status: 'open',
              totalCharges: new Prisma.Decimal(rateNumber),
              totalPayments: new Prisma.Decimal(0),
              balance: new Prisma.Decimal(rateNumber),
            },
          });

          await tx.folioCharge.create({
            data: {
              folioId: folio.id,
              description: `Room rate - ${reservation.room.roomNumber || 'N/A'}`,
              category: 'room_rate',
              amount: new Prisma.Decimal(rateNumber),
              quantity: 1,
              total: new Prisma.Decimal(rateNumber),
            },
          });
        }
      });

      const updatedReservation = await prisma.reservation.findFirst({
        where: {
          id: reservationId,
          tenantId,
        },
        include: {
          room: true,
          folios: {
            include: {
              charges: true,
              payments: true,
            },
          },
        },
      });

      if (!updatedReservation) {
        throw new AppError('Reservation not found after check-in', 500);
      }

      const serializedReservation = {
        ...serializeReservation(updatedReservation),
        room: updatedReservation.room,
        folios: updatedReservation.folios.map(serializeFolio),
      };

      await createAuditLog({
        tenantId,
        userId: req.user!.id,
        action: 'checkin',
        entityType: 'reservation',
        entityId: reservationId,
        beforeState,
        afterState: serializedReservation,
        metadata: {
          photo: photo || null,
          roomId: reservation.roomId,
        },
      });

      await createRoomLog({
        tenantId,
        roomId: reservation.roomId,
        type: 'check_in',
        summary: `Guest checked in (Reservation ${updatedReservation.reservationNumber || reservationId})`,
        metadata: {
          reservationId,
          reservationNumber: updatedReservation.reservationNumber || null,
          guestName: updatedReservation.guestName || null,
        },
        user: {
          id: req.user?.id || null,
          name: getUserDisplayName(req.user),
        },
      });

      // Send check-in confirmation email asynchronously
      if (updatedReservation.guestEmail) {
        (async () => {
          try {
            const tenantSettings = await getTenantEmailSettings(tenantId);
            if (tenantSettings) {
              const emailData: ReservationEmailData = {
                reservationNumber: updatedReservation.reservationNumber || reservationId,
                guestName: updatedReservation.guestName || 'Guest',
                guestEmail: updatedReservation.guestEmail,
                checkInDate: updatedReservation.checkInDate,
                checkOutDate: updatedReservation.checkOutDate,
                roomNumber: updatedReservation.room?.roomNumber || 'N/A',
                roomType: updatedReservation.room?.roomType || undefined,
                rate: decimalToNumber(updatedReservation.rate) ?? 0,
                adults: updatedReservation.adults,
                children: updatedReservation.children,
                specialRequests: updatedReservation.specialRequests || undefined,
                propertyName: tenantSettings.propertyName,
                propertyAddress: tenantSettings.propertyAddress || undefined,
                propertyPhone: tenantSettings.propertyPhone || undefined,
                propertyEmail: tenantSettings.propertyEmail || undefined,
              };

              const emailHtml = generateCheckInReminderEmail(emailData);
              await sendEmail({
                to: updatedReservation.guestEmail,
                subject: `Welcome to ${tenantSettings.propertyName}!`,
                html: emailHtml,
              });
            }
          } catch (emailError) {
            console.error('Failed to send check-in confirmation email:', emailError);
            // Don't throw - email failure shouldn't fail the check-in
          }
        })();
      }

      res.json({
        success: true,
        data: serializedReservation,
      });
    } catch (error: any) {
      if (error instanceof AppError) {
        throw error;
      }
      console.error('Error checking in reservation:', error);
      throw new AppError(
        `Failed to check in reservation: ${error.message || 'Database connection error'}`,
        500
      );
    }
  }
);

// POST /api/tenants/:tenantId/rooms/:roomId/checkout
reservationRouter.post(
  '/:id/checkout',
  authenticate,
  requireTenantAccess,
  async (req: AuthRequest, res) => {
    try {
      const tenantId = req.params.tenantId;
      const reservationId = req.params.id;
      const { finalCharges, paymentInfo } = req.body;
      if (!prisma) {
        throw new AppError('Database connection not initialized', 500);
      }

      const reservation = await prisma.reservation.findFirst({
        where: {
          id: reservationId,
          tenantId,
        },
        include: {
          room: true,
          folios: {
            include: {
              charges: true,
              payments: true,
            },
          },
        },
      });

      if (!reservation) {
        throw new AppError('Reservation not found', 404);
      }

      if (reservation.status !== 'checked_in') {
        throw new AppError('Reservation is not checked in', 400);
      }

      if (!reservation.room) {
        throw new AppError('Reservation is missing room information', 400);
      }

      const beforeState = {
        ...serializeReservation(reservation),
        room: reservation.room,
        folios: reservation.folios.map(serializeFolio),
      };

      const checkOutTime = new Date();

      await prisma.$transaction(async (tx) => {
        await tx.reservation.update({
          where: { id: reservation.id },
          data: {
            status: 'checked_out',
            checkedOutAt: checkOutTime,
            checkedOutBy: req.user!.id,
          },
        });

        await tx.room.update({
          where: { id: reservation.roomId },
          data: {
            status: 'dirty',
          },
        });

        await tx.folio.updateMany({
          where: { reservationId },
          data: {
            status: 'closed',
            closedAt: checkOutTime,
            closedBy: req.user!.id,
          },
        });
      });

      const updatedReservation = await prisma.reservation.findFirst({
        where: {
          id: reservationId,
          tenantId,
        },
        include: {
          room: true,
          folios: {
            include: {
              charges: true,
              payments: true,
            },
          },
        },
      });

      if (!updatedReservation) {
        throw new AppError('Reservation not found after checkout', 500);
      }

      const serializedReservation = {
        ...serializeReservation(updatedReservation),
        room: updatedReservation.room,
        folios: updatedReservation.folios.map(serializeFolio),
      };

      await createAuditLog({
        tenantId,
        userId: req.user!.id,
        action: 'checkout',
        entityType: 'reservation',
        entityId: reservationId,
        beforeState,
        afterState: serializedReservation,
        metadata: {
          finalCharges,
          paymentInfo,
        },
      });

      await createRoomLog({
        tenantId,
        roomId: reservation.roomId,
        type: 'check_out',
        summary: `Guest checked out (Reservation ${updatedReservation.reservationNumber || reservationId})`,
        metadata: {
          reservationId,
          reservationNumber: updatedReservation.reservationNumber || null,
          finalCharges: finalCharges || null,
          paymentInfo: paymentInfo || null,
        },
        user: {
          id: req.user?.id || null,
          name: getUserDisplayName(req.user),
        },
      });

      // Send checkout thank you email asynchronously
      if (updatedReservation.guestEmail) {
        (async () => {
          try {
            const tenantSettings = await getTenantEmailSettings(tenantId);
            if (tenantSettings) {
              const folioData = updatedReservation.folios[0];
              const emailData: ReservationEmailData & { totalCharges?: number } = {
                reservationNumber: updatedReservation.reservationNumber || reservationId,
                guestName: updatedReservation.guestName || 'Guest',
                guestEmail: updatedReservation.guestEmail,
                checkInDate: updatedReservation.checkInDate,
                checkOutDate: updatedReservation.checkOutDate,
                roomNumber: updatedReservation.room?.roomNumber || 'N/A',
                roomType: updatedReservation.room?.roomType || undefined,
                rate: decimalToNumber(updatedReservation.rate) ?? 0,
                adults: updatedReservation.adults,
                children: updatedReservation.children,
                specialRequests: updatedReservation.specialRequests || undefined,
                propertyName: tenantSettings.propertyName,
                propertyAddress: tenantSettings.propertyAddress || undefined,
                propertyPhone: tenantSettings.propertyPhone || undefined,
                propertyEmail: tenantSettings.propertyEmail || undefined,
                totalCharges: folioData
                  ? decimalToNumber(folioData.totalCharges) ?? undefined
                  : undefined,
              };

              const emailHtml = generateCheckOutThankYouEmail(emailData);
              await sendEmail({
                to: updatedReservation.guestEmail,
                subject: `Thank you for staying at ${tenantSettings.propertyName}!`,
                html: emailHtml,
              });
            }
          } catch (emailError) {
            console.error('Failed to send checkout thank you email:', emailError);
            // Don't throw - email failure shouldn't fail the checkout
          }
        })();
      }

      res.json({
        success: true,
        data: serializedReservation,
      });
    } catch (error: any) {
      if (error instanceof AppError) {
        throw error;
      }
      console.error('Error checking out reservation:', error);
      throw new AppError(
        `Failed to check out reservation: ${error.message || 'Database connection error'}`,
        500
      );
    }
  }
);
